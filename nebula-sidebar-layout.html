<!--
@license
Copyright (c) 2017 Ars Nebula LLC.
This code may be used under the terms found in LICENSE.md of this repository.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../nebula-style-attributes-behavior/nebula-style-attributes-behavior.html">

<!--
`<nebula-sidebar-layout>` is a web component to display a collapsable sidebar layout.

## Usage

The layout uses off-screen positioning for the sidebar when collapsed, and is meant to be used as a layout that encompasses the full height and width of the screen.

The following is a typical base style to ensure that the HTML `body` element is sized to fit the browser screen height and width.

```css
html, body {
  position: relative;
  border: 0;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  width: 100%;
  height: 100%;
  overflow: hidden;
  overflow-y: auto;
  box-sizing: border-box;
}
```

The element displays a two-column side-by-side layout with a fixed width sidebar on the left, and a fluid content container on the right. Content is inserted into each column using the `sidebar` and `content` named slots.

```html
<nebula-sidebar-layout
  breakpoint="(max-width: 960px)"
  collapsed="{{collapsed}}"
  opened="{{opened}}"
  on-change="_onSidebarChanged">
  <div slot="sidebar" style="width: 280px"></div>
  <div slot="content"></div>
</nebula-sidebar-layout>
```

The sidebar container width is set to `fit-content`. To specify the width of the sidebar, set a fixed width on the sidebar slot content.

```css
<style>
  nebula-sidebar-layout [slot=sidebar] {
    width: 280px;
  }
</style>
```

The `breakpoint` property specifies the media query that determines when the sidebar is collapsed. The default value collapses the sidebar when the browser screen width is less than 960px. To manually control the collapse of the sidebar, set the `breakpoint` to empty, and then toggle the `collapsed` property value.

```html
<nebula-sidebar-layout breakpoint collapsed="{{collapsed}}">
  <div slot="sidebar"></div>
  <div slot="content"></div>
</nebula-sidebar-layout>
```

## Style

You can style the element using CSS variables and mixins:

Custom property | Description | Default
:--- | :--- | :---
`--nebula-sidebar-layout-backdrop-color` | The color of the backdrop. | hsla(0, 0%, 0%, 0.6)
`--nebula-sidebar-layout-transition-duration` | The speed of transitions. | 0.25s
`--nebula-sidebar-layout-z-index` | The stacking elevation of the sidebar overlay. | 9998

The following styles can also be set as attributes on the element:

- 'backdrop-color'

@demo demo/index.html
-->

<dom-module id="nebula-sidebar-layout">
  <template>
    <style>
      :host {
        --nebula-sidebar-layout-backdrop-color: hsla(0, 0%, 0%, 0.6);
        --nebula-sidebar-layout-transition-duration: 0.25s;
        --nebula-sidebar-layout-z-index: 9998;
        position: relative;
        display: block;
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        border: 0;
        height: 100%;
        width: 100%;
        @apply --layout-horizontal;
        @apply --nebula-sidebar-layout;
      }
      :host([collapsed][opened]) {
        cursor: pointer;
      }
      #content {
        cursor: default;
        margin: 0;
        padding: 0;
        border: 0;
        outline: 0;
        overflow: hidden;
        overflow-y: auto;
        @apply --layout-flex-auto;
        @apply --layout-vertical;
      }
      #content:after {
        content: '';
        position: fixed;
        top: 0;
        bottom: 0;
        right: 0;
        left: 0;
        margin: 0;
        padding: 0;
        border: 0;
        background-color: var(--nebula-sidebar-layout-backdrop-color);
        visibility: hidden;
        opacity: 0;
        transition: opacity var(--nebula-sidebar-layout-transition-duration) linear, visibility 0s linear var(--nebula-sidebar-layout-transition-duration);
      }
      :host([collapsed][opened]) #content:after {
        visibility: visible;
        opacity: 1;
        transition: opacity var(--nebula-sidebar-layout-transition-duration) linear;
      }
      #sidebar {
        cursor: default;
        margin: 0;
        padding: 0;
        border: 0;
        outline: 0;
        overflow: hidden;
        overflow-y: auto;
        width: fit-content;
        transform: translate3d(0, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration) ease;
        @apply --layout-flex-none;
        @apply --layout-vertical;
      }
      :host([collapsed]) #sidebar {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        visibility: hidden;
        transform: translate3d(-100%, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration) ease, visibility 0s linear var(--nebula-sidebar-layout-transition-duration);
      }
      :host([collapsed][opened]) #sidebar {
        z-index: var(--nebula-sidebar-layout-z-index);
        visibility: visible;
        transform: translate3d(0, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration) ease;
      }
    </style>
    <iron-media-query query="[[breakpoint]]" query-matches="{{match}}"></iron-media-query>
    <div id="sidebar" tabindex="-1">
      <slot name="sidebar"></slot>
    </div>
    <div id="content" inert$="{{opened}}" tabindex="-1">
      <slot name="content"></slot>
    </div>
  </template>
  <script>
    Polymer({
      /**
      * Event triggered when the `collapsed` or `opened` properties are changed.
      * Check the event detail for `collapsed` and `opened` values.
      * @event changed
      */
      is: 'nebula-sidebar-layout',
      behaviors: [
        Nebula.StyleAttributesBehavior
      ],
      hostAttributes: {
        'role': 'dialog'
      },
      /**
      * A map of attributes that will update CSS variables.
      */
      _styleAttributes: {
        'backdrop-color': '--nebula-sidebar-layout-backdrop-color',
        'width': '--nebula-sidebar-layout-width'
      },
      properties: {
        /**
        * Indicates if the element is opened.
        * The property is ignored if the element is not collapsed.
        */
        opened: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false
        },
        /**
        * Indicates if the element is collapsed.
        */
        collapsed: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false
        },
        /**
        * Media query expression used as the breakpoint for collapsing the element.
        * Set to null to collapse the element manually.
        */
        breakpoint: {
          type: String,
          value: '(max-width: 960px)'
        },
        /**
        * Indicates if gesture support to swipe the element open and closed is enabled.
        */
        enableSwipe: {
          type: Boolean,
          value: false
        }
      },
      listeners: {
        'tap': '_onTap',
        'track': '_onTrack'
      },
      observers: [
        '_onOpenedChanged(opened)',
        '_onCollapsedChanged(collapsed)',
        '_onMatchChanged(match)'
      ],
      attached: function() {
        this.listen(document.body, 'track', '_onTrack')
      },
      detached: function() {
        this.unlisten(document.body, 'track', '_onTrack')
      },     
      /**
      * Event handler triggered when the element is tapped.
      */
      _onTap: function(e) {
        if (this.opened) {
          e.preventDefault()
          this.close()
        }
      },
      /**
      * Event handler triggered when a touch or mouse gesture occurs.
      */
      _onTrack: function(e) {
        if (this.opened === void(0)) return
        if (!this.enableSwipe) return

        if (e.detail.state === 'start') {
          if (this.opened === true) {
            // detect if user swiped left from anywhere
            if (e.detail.dx < 0) {
              this.close()
            }
          } else {
            // detect if user swiped right from the left edge of the screen
            if (e.detail.x < 64 && e.detail.dx > 0) {
              this.open()
            }
          }
        }
      },
      /**
      * Property observer triggered when the media query `queryMatches` is changed.
      * The property is only applicable if a breakpoint is set.
      * If the breakpoint is set, it updates the `collapsed` property.
      */
      _onMatchChanged: function(match) {
        if (match === void(0)) return
        if (!(typeof this.breakpoint === 'string' && this.breakpoint.length > 0)) return
        this.set('collapsed', match)
      },
      /**
      * Property observer triggered when the `collapsed` property is changed.
      */
      _onCollapsedChanged: function(collapsed) {
        if (collapsed === void(0)) return
        this.fire('changed', null, {bubbles: false})
      },
      /**
       * 
      * Property observer triggered when the `opened` property is changed.
      */
      _onOpenedChanged: function(opened) {
        if (opened === void(0)) return
        if (opened) {
          this.$.sidebar.focus()
          this.listen(window, 'resize', '_onResize')
          this.fire('changed', null, {bubbles: false})
        } else {
          this.$.content.focus()
          this.unlisten(window, 'resize', '_onResize')
          this.fire('changed', null, {bubbles: false})
        }
      },
      /**
      * Event handler triggered when the window is resized.
      * If the element is currently open, it will close the element.
      */
      _onResize: function(e) {
        this.close()
      },
      /**
      * Opens the element if currently collapsed.
      */
      open: function() {
        if (this.collapsed) {
          this.set('opened', true)
        }        
      },
      /**
      * Closes the element if currently open.
      */ 
      close: function() {
        if (this.opened) {
          this.set('opened', false)
        }        
      }
    })
  </script>
</dom-module>