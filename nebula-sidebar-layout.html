<!--
@license
Copyright (c) 2017 Ars Nebula LLC.
This code may be used under the terms found in LICENSE.md of this repository.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">

<!--
`<nebula-sidebar-layout>` is a web component to display a collapsable sidebar layout.

The element will automatically fill the parent container. It provides two named slots, `sidebar` and `content` configured as a horizontal flexbox. Using the `breakpoint` property, a media query will be monitored that will set the element `collapsed` property. When `collapsed` is true, the `sidebar` slot is changed to an offscreen fixed position container. The sidebar can be displayed using the `opened` property, and will overlay the `content` slot as an animated drawer with a backdrop.

## Usage

The element uses offscreen positioning for the sidebar when collapsed. It can only be used effectively if the parent container fills the entire browser window. The following is a typical base style to ensure that the HTML `body` element is sized to fit the browser screen height and width.

```css
html, body {
  position: relative;
  border: 0;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  width: 100%;
  height: 100%;
  overflow: hidden;
  overflow-y: auto;
  box-sizing: border-box;
}
```

The element displays a two-column side-by-side layout with a fixed width sidebar on the left, and a fluid content container on the right. Content is inserted into each column using the `sidebar` and `content` named slots. The `breakpoint` property enables a media query that will set the element `collapsed` property. When `collapsed` is true, the `sidebar` slot is changed to an offscreen fixed position container. The sidebar can be displayed using the `opened` property, and will overlay the `content` slot as an animated drawer with a backdrop.

```html
<nebula-sidebar-layout
  breakpoint="(max-width: 960px)"
  collapsed="{{collapsed}}"
  opened="{{opened}}"
  on-change="_onSidebarChanged">
  <div slot="sidebar"></div>
  <div slot="content"></div>
</nebula-sidebar-layout>
```

The sidebar container width is set to `fit-content`. To specify the width of the sidebar, set a fixed width on the sidebar slot content.

```css
<style>
  nebula-sidebar-layout [slot=sidebar] {
    width: 280px;
  }
</style>
```

The `breakpoint` property specifies the media query that determines when the sidebar is collapsed. The default value collapses the sidebar when the browser screen width is less than 960px. To manually control the collapse of the sidebar, set the `breakpoint` to empty, and then toggle the `collapsed` property value manually.

```html
<nebula-sidebar-layout breakpoint collapsed="{{collapsed}}">
</nebula-sidebar-layout>
```

The element includes optional gesture support for opening and closing the sidebar by swiping left and right on touchscreen devices. Some mobile browsers use this gesture to switch browser tabs, so gesture support is disabled by default. To enable gesture support (such as for Cordova or Electron apps), set the `gesturesEnabled' property to `true`.

```html
<nebula-sidebar-layout gestures-enabled>
</nebula-sidebar-layout>
```

## Style

Theme variables are used to style key design goals for the element and affect multiple styles (border, background color) across multiple states.

Custom property | Description | Default
:--- | :--- | :---
`--nebula-sidebar-layout-backdrop-color` | The color of the backdrop. | hsla(0, 0%, 0%, 0.6)
`--nebula-sidebar-layout-transition-duration` | The speed of transitions. | 0.25s

For more granular control, the following mixins can be used to style each state of the element:

Custom property | Description
:--- | :---
`--nebula-sidebar-layout` | Mixin applied to base element.
`--nebula-sidebar-layout-sidebar` | Mixin applied to the sidebar slot container.
`--nebula-sidebar-layout-content` | Mixin applied to the content slot container.
`--nebula-sidebar-layout-backdrop` | Mixin applied to backdrop pseudo element.
`--nebula-sidebar-layout-collapsed` | Mixin applied to base element when collapsed.
`--nebula-sidebar-layout-collapsed-sidebar` | Mixin applied to the sidebar slot container when collapsed.
`--nebula-sidebar-layout-opened` | Mixin applied to base element when opened.
`--nebula-sidebar-layout-opened-sidebar` | Mixin applied to the sidebar slot container when opened.
`--nebula-sidebar-layout-opened-backdrop` | Mixin applied to the backdrop pseudo-element when opened.

The element also inherits default values from the following global theme styles. If a global theme variable has not been set, it will use the local default.

Custom property | Description
:--- | :---
`--nebula-ui-backdrop-color` | The background color of the backdrop pseudo element.

@demo demo/index.html
-->

<dom-module id="nebula-sidebar-layout">
  <template>
    <style>
      :host {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
        position: relative;
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        border: 0;
        height: 100%;
        width: 100%;
        @apply --nebula-sidebar-layout;
      }
      :host([collapsed]) {
        @apply --nebula-sidebar-layout-collapsed;
      }
      :host([collapsed][opened]) {
        cursor: pointer;
        @apply --nebula-sidebar-layout-opened;
      }
      #content {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
        -ms-flex: 1 1 auto;
        -webkit-flex: 1 1 auto;
        flex: 1 1 auto;
        cursor: default;
        margin: 0;
        padding: 0;
        border: 0;
        outline: 0;
        overflow: hidden;
        overflow-y: auto;
        @apply --nebula-sidebar-layout-content;
      }
      #content:after {
        content: '';
        position: fixed;
        top: 0;
        bottom: 0;
        right: 0;
        left: 0;
        margin: 0;
        padding: 0;
        border: 0;
        background-color: var(--nebula-sidebar-layout-backdrop-color, var(--nebula-ui-backdrop-color, hsla(0, 0%, 0%, 0.6)));
        visibility: hidden;
        opacity: 0;
        transition: opacity var(--nebula-sidebar-layout-transition-duration, 0.25s) linear, visibility 0s linear var(--nebula-sidebar-layout-transition-duration, 0.25s);
        @apply --nebula-sidebar-layout-backdrop;
      }
      :host([collapsed][opened]) #content:after {
        visibility: visible;
        opacity: 1;
        transition: opacity var(--nebula-sidebar-layout-transition-duration, 0.25s) linear;
        @apply --nebula-sidebar-layout-opened-backdrop;
      }
      :host #sidebar {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
        -ms-flex: none;
        -webkit-flex: none;
        flex: none;
        cursor: default;
        margin: 0;
        padding: 0;
        border: 0;
        outline: 0;
        overflow: hidden;
        overflow-y: auto;
        width: fit-content;
        transform: translate3d(0, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration, 0.25s) ease;
        @apply --nebula-sidebar-layout-sidebar;
      }

      :host([right]) #sidebar {
        right: 0;
        @apply --nebula-sidebar-layout-sidebar;
        @apply --nebula-sidebar-layout-right-sidebar;
      }

      :host([right][collapsed]) #sidebar {
        position: fixed;
        right: 0;
        left: inherit;
        top: 0;
        bottom: 0;
        visibility: hidden;
        transform: translate3d(100%, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration, 0.25s) ease, visibility 0s linear var(--nebula-sidebar-layout-transition-duration, 0.25s);
        @apply --nebula-sidebar-layout-collapsed-sidebar;
        @apply --nebula-sidebar-layout-right-collapsed-sidebar;
      }

      :host([collapsed]) #sidebar {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        visibility: hidden;
        transform: translate3d(-100%, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration, 0.25s) ease, visibility 0s linear var(--nebula-sidebar-layout-transition-duration, 0.25s);
        @apply --nebula-sidebar-layout-collapsed-sidebar;
      }

      :host([right][collapsed][opened]) #sidebar {
        z-index: 9998;
        visibility: visible;
        transform: translate3d(0, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration, 0.25s) ease;
        @apply --nebula-sidebar-layout-opened-sidebar;
        @apply --nebula-sidebar-layout-right-opened-sidebar;
      }

      :host([collapsed][opened]) #sidebar {
        z-index: 9998;
        visibility: visible;
        transform: translate3d(0, 0, 0);
        transition: transform var(--nebula-sidebar-layout-transition-duration, 0.25s) ease;
        @apply --nebula-sidebar-layout-opened-sidebar;
      }
    </style>
    <iron-media-query query="[[breakpoint]]" query-matches="{{match}}"></iron-media-query>
    <template is="dom-if" if="{{!right}}">
      <div id="sidebar" tabindex="-1">
        <slot name="sidebar"></slot>
      </div>
      <div id="content" inert$="{{opened}}" tabindex="-1">
        <slot name="content"></slot>
      </div>
    </template>

    <template is="dom-if" if="{{right}}">
      <div id="content" inert$="{{opened}}" tabindex="-1">
        <slot name="content"></slot>
      </div>
      <div id="sidebar" tabindex="-1">
        <slot name="sidebar"></slot>
      </div>
    </template>
  </template>
  <script>
    Polymer({
      /**
      * Event triggered when the `collapsed` or `opened` properties are changed.
      * @event changed
      */
      is: 'nebula-sidebar-layout',
      hostAttributes: {
        'role': 'dialog'
      },
      properties: {
        right: {
          type: Boolean,
          value: false
        },
        /**
        * Indicates if the element is opened.
        * The property is ignored if the element is not collapsed.
        */
        opened: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false
        },
        /**
        * Indicates if the element is collapsed.
        */
        collapsed: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false
        },
        /**
        * Media query expression used as the breakpoint for collapsing the element.
        * Set to null to collapse the element manually.
        */
        breakpoint: {
          type: String,
          value: '(max-width: 960px)'
        },
        /**
        * Indicates if gesture support to swipe the element open and closed is supported.
        */
        gesturesEnabled: {
          type: Boolean,
          value: false
        }
      },
      listeners: {
        'tap': '_onTap'
      },
      observers: [
        '_onOpenedChanged(opened)',
        '_onCollapsedChanged(collapsed)',
        '_onBreakpointMatchChanged(breakpoint, match)'
      ],
      attached: function() {
        this.listen(document.body, 'track', '_onTrack')
      },
      detached: function() {
        this.unlisten(document.body, 'track', '_onTrack')
      },
      /**
      * Event handler triggered when the element is tapped.
      * If the element is collapsed and open, it will close the element.
      */
      _onTap: function(e) {
        if (this.opened) {
          e.preventDefault()
          this.close()
        }
      },
      /**
      * Event handler triggered when a touch or mouse gesture occurs.
      */
      _onTrack: function(e) {
        if (this.opened === void(0)) return
        if (!this.gesturesEnabled) return

        if (e.detail.state === 'start') {
          if (this.opened === true) {
            // detect if user swiped left from anywhere
            if (e.detail.dx < 0) {
              this.async(this.close)
            }
          } else {
            // detect if user swiped right from the left edge of the screen
            if (e.detail.x < 64 && e.detail.dx > 0) {
              this.async(this.open)
            }
          }
        }
      },
      /**
      * Property observer triggered when the media query `queryMatches` is changed.
      * The property is only applicable if a breakpoint is set.
      * If the breakpoint is set, it updates the `collapsed` property.
      */
      _onBreakpointMatchChanged: function(breakpoint, match) {
        if (!(typeof breakpoint === 'string' && breakpoint.length > 0)) return
        if (match === void(0)) return
        this.set('collapsed', match)
      },
      /**
      * Property observer triggered when the `collapsed` property is changed.
      */
      _onCollapsedChanged: function(collapsed) {
        if (collapsed === void(0)) return
        this.fire('changed', null, {bubbles: false})
      },
      /**
       *
      * Property observer triggered when the `opened` property is changed.
      */
      _onOpenedChanged: function(opened) {
        if (opened === void(0)) return
        if (opened) {
          this.listen(window, 'resize', '_onResize')
        } else {
          this.unlisten(window, 'resize', '_onResize')
        }
        this.fire('changed', null, {bubbles: false})
      },
      /**
      * Event handler triggered when the window is resized.
      * If the element is currently open, it will close the element.
      */
      _onResize: function(e) {
        this.close()
      },
      /**
      * Opens the element if currently collapsed.
      */
      open: function() {
        if (this.collapsed) {
          this.set('opened', true)
        }
      },
      /**
      * Closes the element if currently open.
      */
      close: function() {
        if (this.opened) {
          this.set('opened', false)
        }
      }
    })
  </script>
</dom-module>
